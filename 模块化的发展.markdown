### 最初的开发——没有模块化
  按照顺序引入文件，把整合的文件放在最后引入

  问题：
  - 没有办法维护
    - 不清楚整合文件main.js 到底依赖了哪些文件。
  - 全局变量污染
  - 依赖关系不清
    - js文件内是否相互依赖不清晰

### IIFE 伪模块化标准 2003——2011
  + Immediately Invoked FUnction Expression
  + 所有的代码放在一个自执行函数中

  解决问题：
  + 解决了依赖不清的问题
    + 直接在自执行函数的参数位置，能看到有哪些依赖
  + 解决了变量全局污染的问题

  问题：
  + 文件顺序还是不能动
  + 只能知道依赖了哪几个模块，但是模块在哪一个文件中不清楚

### CommonJS 模块化标准 
  + 2009， NodeJS出现
  + 只能在后端JS中使用

### AMD 模块化标准 Async Module Definition （依赖前置）
  + 2011 社区发起
  + 非官方，没有关键字，需要require.js 实现模块化标准
  + 把每一个js文件独立出来了
    + 使用了导入导出的语法
    + 在js文件中引入另一个js文件
  + 定义模块,调用define 和require 函数
    + 独立模块定义
      + 每一个独立模块开始执行define函数
      + 独立模块不依赖其他文件
      + 向外暴露的内容，直接return出去
    + 依赖其他模块的模块
      + 非独立模块，依赖其他模块的内容
      + 使用define 定义
      + 语法： define( [依赖文件1, 依赖文件2, ...], function(别名1, ...){})
    + 整合模块
      + 模块整合文件，使用require（）函数
      + 语法：require( [依赖文件1, 依赖文件2, ...], function(别名1, ...){})
  + 解决问题： 
    + 依赖很清晰
    + 没有变量全局污染
  + 问题： 
    + 依赖前置加载
      + 依赖全部加载完后，才能继续执行
      + 首屏加载时间长，但后期操作流畅

### CMD Common Module Definition （即时依赖）
  + 2011 社区标准
  + 依赖 sea.js 文件
  + 独立模块定义
    + define(function( require, exports, module){})
      + require() 用来导入其他文件
      + exports = module.exports 本文件导出
  + 依赖其他模块的模块
    + 在需要依赖的地方使用：
      + var modA = require('./a.js') //即时依赖
  + 模块整合
    + 使用seajs.use()
    + 语法： seajs.use( [依赖的模块1, ...], function(别名1, ...) {})
  + 解决问题：
    + 依赖前置： 按需加载，需要时再加载，也有依赖前置的接口

### ES2015 module
  + ES6语法自带模块化标准
  + 特点： 
    + 页面必须在服务器上打开
    + html引入此类js ，script标签必须要加上type= module
    + 单个文件的引入并不会通过script标签引入页面，所以变量不会是全局变量
  + 使用： 
    + 每一个文件都可以作为独立模块，也可以作为整合文件
    + 导出语法：
      + export default { 导出的内容 }
      + export var num = 200
    + 导入语法： 
      + import 变量 from ' js文件' //接收 export default
      +  import {  变量 } from 'js文件'
 +  解决问题： 
    +  编程关键字，不需要依赖第三方文件
    +  每一个文件都是模块文件，也可以是整合文件
 +  暴漏问题： 
    +  浏览器支持性不好,需要在服务器上打开
    +  依赖前置

  ### ES2020 按需加载语法
  + 语法： import('js文件').then( res => {})